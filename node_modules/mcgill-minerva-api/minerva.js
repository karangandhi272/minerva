'use strict';

var q = require('q');
var _ = require('lodash');

var CONSTANTS = require('./lib/CONSTANTS.js');
var Request = require('./lib/request-util');
var Parser = require('./lib/parser');
var utils = require('./lib/utils');

function login(user) {
  var deferred = q.defer();

  var url = CONSTANTS.URLS.login;
  var jar = Request.jar('TESTID=set');
  var form = {
    sid:  user.username,
    PIN:  user.password
  };

  function retry(jar, retry_count) {
    retry_count = retry_count;
    return Request.post(url, jar, form)
    .then(function(promised_obj) {
      var cookie_string = promised_obj.jar.getCookieString(CONSTANTS.BASE_URL + '/');
      var contains_sessid = cookie_string.indexOf('SESSID=') !== -1;
      if (contains_sessid) {
        deferred.resolve(promised_obj);
      } else {
        if (retry_count < CONSTANTS.MAX_RETRY_COUNT) {
          retry(promised_obj.jar, retry_count + 1);
        } else {
          deferred.reject(new Error('could not login'));
        }
      }
    });
  }

  retry(jar, 1);

  return deferred.promise;
}

function promiseTranscript() {
  return function(promised_obj) {
    var deferred = q.defer();

    var url = CONSTANTS.URLS.transcript;
    var jar = promised_obj.jar;

    Request.get(url, jar)
    .then(function(promised_obj) {
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        deferred.reject(new Error('got 404'));
      }
    });

    return deferred.promise;
  };
}

function promiseCourses(selection) {
  return function(promised_obj) {
    // this is a hack cause I have no clue what the fuck is going on with
    // McGill's post data on that form. Somehow they duplicate keys, put dummy
    // somewhere, some random %25s, ...  I'm not sure but I think I have to
    // write the damn thing by hand and in order.  sooo... This is my not so
    // elegant solution but it works and I'm happy :) If you can refactor it,
    // feel free :)
    function formUrlEncode(sel) {
      // sel keys : dep, number, season, year
      // season matches WSF for winter summer fall
      var sn = utils.fmtSeason(sel.season);
      var termCode = (sel.year || '2025') + sn;

      var boilerplate = [
      "term_in=" + termCode,
      "&sel_subj=dummy",
      "&sel_subj=" + (sel.dep || 'COMP').toUpperCase(),
      "&SEL_CRSE=" + (sel.number || ''),
      "&SEL_TITLE=",
      "&BEGIN_HH=0",
      "&BEGIN_MI=0",
      "&BEGIN_AP=a",
      "&SEL_DAY=dummy",
      "&SEL_PTRM=dummy",
      "&END_HH=0",
      "&END_MI=0",
      "&END_AP=a",
      "&SEL_CAMP=dummy",
      "&SEL_SCHD=dummy",
      "&SEL_SESS=dummy",
      "&SEL_INSTR=dummy",
      "&SEL_INSTR=%25",
      "&SEL_ATTR=dummy",
      "&SEL_ATTR=%25",
      "&SEL_LEVL=dummy",
      "&SEL_LEVL=%25",
      "&SEL_INSM=dummy",
      "&sel_dunt_code=",
      "&sel_dunt_unit=",
      "&call_value_in=",
      "&rsts=dummy",
      "&crn=dummy",
      "&path=1",
      "&SUB_BTN=View+Sections"
    ].join('');
    return boilerplate;
    }

    var deferred = q.defer();

    var url = CONSTANTS.URLS.select_courses;
    var jar = promised_obj.jar;
    var form = formUrlEncode(selection || {});

    Request.post(url, jar, form)
    .then(

    // success callback
    function(coursesJarAndBody) {
      if (utils.isLoggedIn(coursesJarAndBody.body)) {
        deferred.resolve(coursesJarAndBody);
      } else {
        deferred.reject(new Error('couldnt resolve course selection'));
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseRegisteredCourses(options) {
  return function(promised_obj) {
    var deferred = q.defer();

    var url = CONSTANTS.URLS.registered_courses;
    var jar = promised_obj.jar;
    var form = {
      term_in: (options.year || '2025') + utils.fmtSeason(options.season)
    };

    Request.post(url, jar, form)
    .then(

    // success callback
    function(promised_obj) {
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        deferred.reject(new Error('couldnt get list of registered_courses'));
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseAddOrDropCourse(drop, selection) {
  return function(promised_obj) {
    var deferred = q.defer();
    
    console.log('Add/Drop course request:', { drop: drop, selection: selection });
    
    // Get current registered courses first
    var url = CONSTANTS.URLS.registered_courses;
    var jar = promised_obj.jar;
    var sn = utils.fmtSeason(selection.season);
    var termCode = (selection.year || '2025') + sn;
    
    console.log('Term code:', termCode);
    
    var form = {
      term_in: termCode
    };

    Request.post(url, jar, form)
    .then(function(registeredCoursesResponse) {
      console.log('Got registered courses response');
      
      // Parse the current registered courses
      var currentCourses = [];
      try {
        currentCourses = Parser.parseRegisteredCourses(registeredCoursesResponse.body);
        console.log('Current courses:', currentCourses);
      } catch (parseError) {
        console.log('Error parsing current courses:', parseError);
        currentCourses = [];
      }
      
      // Now build the add/drop form based on current state
      function buildAddDropForm(currentCourses, sel, isDrop) {
        var formParts = [];
        
        console.log('Building form for:', { isDrop: isDrop, crn: sel.crn, currentCoursesCount: currentCourses.length });
        
        // Header - required dummy entries (exactly matching the reference)
        formParts.push("term_in=" + encodeURIComponent(termCode));
        formParts.push("RSTS_IN=DUMMY");
        formParts.push("assoc_term_in=DUMMY");
        formParts.push("CRN_IN=DUMMY");
        formParts.push("start_date_in=DUMMY");
        formParts.push("end_date_in=DUMMY");
        formParts.push("SUBJ=DUMMY");
        formParts.push("CRSE=DUMMY");
        formParts.push("SEC=DUMMY");
        formParts.push("LEVL=DUMMY");
        formParts.push("CRED=DUMMY");
        formParts.push("GMOD=DUMMY");
        formParts.push("TITLE=DUMMY");
        formParts.push("MESG=DUMMY");
        formParts.push("REG_BTN=DUMMY");
        formParts.push("MESG=DUMMY");

        // Convert CRN to array if it's not already
        var crnArray = sel.crn;
        if (!(crnArray instanceof Array)) {
          crnArray = [crnArray];
        }
        
        console.log('CRN array:', crnArray);

        // Add entries for each currently registered course
        var registeredCount = 0;
        if (currentCourses && currentCourses.length > 0) {
          currentCourses.forEach(function(course) {
            if (course.crn) {
              // Check if this course is being dropped
              var isBeingDropped = isDrop && crnArray.indexOf(course.crn.toString()) !== -1;
              
              console.log('Processing current course:', { crn: course.crn, isBeingDropped: isBeingDropped });
              
              // For courses being dropped, set RSTS_IN to "DW", otherwise leave empty
              formParts.push("RSTS_IN" + (isBeingDropped ? "=DW" : ""));
              formParts.push("assoc_term_in=" + encodeURIComponent(termCode));
              formParts.push("CRN_IN=" + encodeURIComponent(course.crn));
              
              // Use proper date format based on season - fixed for winter semester
              var startDate, endDate;
              if (selection.season.toLowerCase() === 'w') {
                // Winter semester: term 202501 runs in calendar year 2026
                var winterYear = parseInt(selection.year || '2025');
                startDate = "01/05/" + winterYear;
                endDate = "04/14/" + winterYear;
              } else if (selection.season.toLowerCase() === 's') {
                startDate = "05/01/" + (selection.year || '2025');
                endDate = "08/15/" + (selection.year || '2025');
              } else { // fall
                startDate = "08/27/" + (selection.year || '2025');
                endDate = "12/03/" + (selection.year || '2025');
              }
              
              formParts.push("start_date_in=" + encodeURIComponent(course.start_date || startDate));
              formParts.push("end_date_in=" + encodeURIComponent(course.end_date || endDate));
              formParts.push("SUBJ=" + encodeURIComponent(course.department || ""));
              formParts.push("CRSE=" + encodeURIComponent(course.course_number || ""));
              formParts.push("SEC=" + encodeURIComponent(course.section || ""));
              formParts.push("LEVL=" + encodeURIComponent(course.level || "Undergraduate"));
              formParts.push("CRED=" + encodeURIComponent(course.credits || course.credit || "3.000"));
              formParts.push("GMOD=" + encodeURIComponent(course.gmod || "Standard"));
              formParts.push("TITLE=" + encodeURIComponent(course.title || ""));
              formParts.push("MESG=DUMMY");
              
              registeredCount++;
            }
          });
        }

        // Add empty slots for additional courses - this is where new courses go
        var addSlotsUsed = 0;
        
        // For adding courses, put them in the first empty slots
        crnArray.forEach(function(crn) {
          console.log('Adding new course with CRN:', crn);
          
          // Use proper date format based on season - fixed for winter semester
          var startDate, endDate;
          if (selection.season.toLowerCase() === 'w') {
            // Winter semester: term 202501 runs in calendar year 2026
            var winterYear = parseInt(selection.year || '2025');
            startDate = "01/05/" + winterYear;
            endDate = "04/14/" + winterYear;
          } else if (selection.season.toLowerCase() === 's') {
            startDate = "05/01/" + (selection.year || '2025');
            endDate = "08/15/" + (selection.year || '2025');
          } else { // fall
            startDate = "08/27/" + (selection.year || '2025');
            endDate = "12/03/" + (selection.year || '2025');
          }
          
          formParts.push("RSTS_IN=RW");
          formParts.push("CRN_IN=" + encodeURIComponent(crn));
          formParts.push("assoc_term_in=" + encodeURIComponent(termCode));
          formParts.push("start_date_in=" + startDate);
          formParts.push("end_date_in=" + endDate);
          
          addSlotsUsed++;
        });
        
        // Fill remaining empty slots (matching the reference format exactly)
        for (var i = addSlotsUsed; i < 10; i++) {
          formParts.push("RSTS_IN=RW");
          formParts.push("CRN_IN=");
          formParts.push("assoc_term_in=");
          formParts.push("start_date_in=");
          formParts.push("end_date_in=");
        }

        // Footer with counters and submit button (exactly matching reference)
        formParts.push("regs_row=" + registeredCount);
        formParts.push("wait_row=0");
        formParts.push("add_row=10");
        formParts.push("REG_BTN=Submit Changes");

        var formString = formParts.join('&');
        console.log('Generated form data (first 1000 chars):', formString.substring(0, 1000));
        
        return formString;
      }

      // Build the form and make the add/drop request
      var addDropForm = buildAddDropForm(currentCourses, selection, drop);
      var addDropUrl = CONSTANTS.URLS.add_courses;
      
      console.log('Making add/drop request to:', addDropUrl);

      Request.post(addDropUrl, jar, addDropForm)
      .then(function(promised_obj) {
        console.log('Add/drop response received, body length:', promised_obj.body ? promised_obj.body.length : 0);
        
        if (utils.isLoggedIn(promised_obj.body)) {
          console.log('Add/drop request successful');
          deferred.resolve(promised_obj);
        } else {
          console.log('Add/drop request failed - not logged in or bad response');
          deferred.reject(new Error('Add/drop request failed - authentication or server error'));
        }
      })
      .catch(function(err) {
        console.log('Add/drop request error:', err);
        deferred.reject(err);
      });
    })
    .catch(function(err) {
      console.log('Error getting current registered courses:', err);
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseAddCourses(selection) {
  return promiseAddOrDropCourse(false, selection);
}

function promiseDropCourses(selection) {
  return promiseAddOrDropCourse(true, selection);
}

function promiseViewCourse(selection) {
  return function(promised_obj) {
    var deferred = q.defer();

    // Use the correct URL for viewing course details
    var url = CONSTANTS.URLS.view_course_detail;
    var jar = promised_obj.jar;
    var sn = utils.fmtSeason(selection.season);
    var termCode = (selection.year || '2025') + sn;

    var gotodate; 
    var startdate;

    if (selection.season == 'W') {
      gotodate = '09/01/' + (selection.year || '2025');
      startdate = '06/30/' + (selection.year || '2025');
  


    }
    else {
      gotodate = '01/05/' + (selection.year || '2025');

    }

    
    // Build form data matching the expected MIME type format
    var formData = {
      'goto_date_in':  gotodate,
      'start_date_in': startdate,
      'pers_id': '',
      'user_type': ''
    };

    console.log('ViewCourse request:', { url, formData });

    Request.post(url, jar, formData)
    .then(

    // success callback
    function(promised_obj) {
      console.log('ViewCourse response received, body length:', promised_obj.body ? promised_obj.body.length : 0);
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        console.log('ViewCourse: Not logged in or empty response');
        deferred.reject(new Error('couldnt get course details - not logged in'));
      }
    },

    // error callback
    function(err) {
      console.log('ViewCourse error:', err);
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseWeeklySchedule(options) {
  return function(promised_obj) {
    var deferred = q.defer();

    // Use GET request instead of POST to match the browser behavior
    var url = CONSTANTS.URLS.weekly_schedule || CONSTANTS.BASE_URL + '/bwskfshd.P_CrseSchd';
    var jar = promised_obj.jar;
    var sn = utils.fmtSeason(options.season);
    var termCode = (options.year || '2025') + sn;

    // Set proper date based on season and year - corrected for winter semester
    var startDate;
    if (options.season.toLowerCase() === 'w') {
      // Winter semester runs January-April of the SAME year
      startDate = '01/05/' + (options.year || '2025');
    } else if (options.season.toLowerCase() === 's') {
      startDate = '05/01/' + (options.year || '2025');
    } else { // fall
      startDate = '09/01/' + (options.year || '2025');
    }

    // Use GET request with query parameters like the browser does
    var fullUrl = url + '?start_date_in=' + encodeURIComponent(startDate) + '&pers_id=&user_type=';

    console.log('Weekly schedule request:', { url: fullUrl, season: options.season, year: options.year, calculatedStartDate: startDate });

    Request.get(fullUrl, jar)
    .then(

    // success callback
    function(promised_obj) {
      console.log('Weekly schedule response received, body length:', promised_obj.body ? promised_obj.body.length : 0);
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        console.log('Weekly schedule: Not logged in or empty response');
        deferred.reject(new Error('couldnt get weekly schedule - not logged in'));
      }
    },

    // error callback
    function(err) {
      console.log('Weekly schedule error:', err);
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

var Minerva = function(u, p) {
  this.username = u || process.env.MG_USER;
  this.password = p || process.env.MG_PASS;
};

Minerva.prototype = {

  // for testing and backward compatibility
  login: function() {
    return login(this);
  },

  getTranscript: function() {
    var deferred = q.defer();

    login(this)
    .then(promiseTranscript())
    .then(

    // success callback
    function(promised_obj) {
      var html = promised_obj.body;
      if (!utils.isLoggedIn(html)) {
        deferred.reject(new Error('404'));
      } else {
        deferred.resolve(Parser.parseTranscript(html));
      }
    },

    // failure callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  getCourses: function(selection) {
    var deferred = q.defer();

    login(this)
    .then(promiseCourses(selection))
    .then(

    // success callback
    function(promised_obj) {
      deferred.resolve(Parser.parseCourses(promised_obj.body));
    },

    // failure callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  getRegisteredCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseRegisteredCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      deferred.resolve(Parser.parseRegisteredCourses(promised_obj.body));
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  addCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseAddCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      var courses = Parser.parseRegisteredCourses(promised_obj.body);
      var error = _.find(courses, 'ErrorMsg');
      if (error) {
        deferred.reject(new Error(error.ErrorMsg));
      } else {
        deferred.resolve(courses);
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  dropCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseDropCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      var courses = Parser.parseRegisteredCourses(promised_obj.body);
      var error = _.find(courses, 'ErrorMsg');
      if (error) {
        deferred.reject(new Error(error.ErrorMsg));
      } else {
        deferred.resolve(courses);
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  viewCourse: function(selection) {
    var deferred = q.defer();

    console.log('ViewCourse called with selection:', selection);

    login(this)
    .then(promiseViewCourse(selection))
    .then(

    // success callback
    function(promised_obj) {
      console.log('ViewCourse: Parsing course detail from response');
      try {
        var result = Parser.parseCourseDetail(promised_obj.body);
        console.log('ViewCourse: Parsed result:', result);
        deferred.resolve(result);
      } catch (parseError) {
        console.log('ViewCourse: Parse error:', parseError);
        deferred.reject(new Error('Failed to parse course details: ' + parseError.message));
      }
    },

    // failure callback
    function(err) {
      console.log('ViewCourse: Promise chain error:', err);
      deferred.reject(err);
    });

    return deferred.promise;
  },

  getWeeklySchedule: function(options) {
    var deferred = q.defer();

    console.log('GetWeeklySchedule called with options:', options);

    login(this)
    .then(promiseWeeklySchedule(options))
    .then(

    // success callback
    function(promised_obj) {
      console.log('WeeklySchedule: Parsing schedule from response');
      try {
        var result = Parser.parseWeeklySchedule(promised_obj.body);
        console.log('WeeklySchedule: Parsed result:', result);
        deferred.resolve(result);
      } catch (parseError) {
        console.log('WeeklySchedule: Parse error:', parseError);
        deferred.reject(new Error('Failed to parse weekly schedule: ' + parseError.message));
      }
    },

    // failure callback
    function(err) {
      console.log('WeeklySchedule: Promise chain error:', err);
      deferred.reject(err);
    });

    return deferred.promise;
  },
};


module.exports = Minerva;
