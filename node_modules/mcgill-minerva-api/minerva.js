'use strict';

var q = require('q');
var _ = require('lodash');

var CONSTANTS = require('./lib/CONSTANTS.js');
var Request = require('./lib/request-util');
var Parser = require('./lib/parser');
var utils = require('./lib/utils');

function login(user) {
  var deferred = q.defer();

  var url = CONSTANTS.URLS.login;
  var jar = Request.jar('TESTID=set');
  var form = {
    sid:  user.username,
    PIN:  user.password
  };

  function retry(jar, retry_count) {
    retry_count = retry_count;
    return Request.post(url, jar, form)
    .then(function(promised_obj) {
      var cookie_string = promised_obj.jar.getCookieString(CONSTANTS.BASE_URL + '/');
      var contains_sessid = cookie_string.indexOf('SESSID=') !== -1;
      if (contains_sessid) {
        deferred.resolve(promised_obj);
      } else {
        if (retry_count < CONSTANTS.MAX_RETRY_COUNT) {
          retry(promised_obj.jar, retry_count + 1);
        } else {
          deferred.reject(new Error('could not login'));
        }
      }
    });
  }

  retry(jar, 1);

  return deferred.promise;
}

function promiseTranscript() {
  return function(promised_obj) {
    var deferred = q.defer();

    var url = CONSTANTS.URLS.transcript;
    var jar = promised_obj.jar;

    Request.get(url, jar)
    .then(function(promised_obj) {
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        deferred.reject(new Error('got 404'));
      }
    });

    return deferred.promise;
  };
}

function promiseCourses(selection) {
  return function(promised_obj) {
    // this is a hack cause I have no clue what the fuck is going on with
    // McGill's post data on that form. Somehow they duplicate keys, put dummy
    // somewhere, some random %25s, ...  I'm not sure but I think I have to
    // write the damn thing by hand and in order.  sooo... This is my not so
    // elegant solution but it works and I'm happy :) If you can refactor it,
    // feel free :)
    function formUrlEncode(sel) {
      // sel keys : dep, number, season, year
      // season matches WSF for winter summer fall
      var sn = utils.fmtSeason(sel.season);

      var boilerplate = [
      "term_in=" + ('202509'),
      "&sel_subj=dummy",
      "&sel_subj=" + (sel.dep || 'COMP').toUpperCase(),
      "&SEL_CRSE=" + (sel.number || ''),
      "&SEL_TITLE=",
      "&BEGIN_HH=0",
      "&BEGIN_MI=0",
      "&BEGIN_AP=a",
      "&SEL_DAY=dummy",
      "&SEL_PTRM=dummy",
      "&END_HH=0",
      "&END_MI=0",
      "&END_AP=a",
      "&SEL_CAMP=dummy",
      "&SEL_SCHD=dummy",
      "&SEL_SESS=dummy",
      "&SEL_INSTR=dummy",
      "&SEL_INSTR=%25",
      "&SEL_ATTR=dummy",
      "&SEL_ATTR=%25",
      "&SEL_LEVL=dummy",
      "&SEL_LEVL=%25",
      "&SEL_INSM=dummy",
      "&sel_dunt_code=",
      "&sel_dunt_unit=",
      "&call_value_in=",
      "&rsts=dummy",
      "&crn=dummy",
      "&path=1",
      "&SUB_BTN=View+Sections"
    ].join('');
    return boilerplate;
    }

    var deferred = q.defer();

    var url = CONSTANTS.URLS.select_courses;
    var jar = promised_obj.jar;
    var form = formUrlEncode(selection || {});

    Request.post(url, jar, form)
    .then(

    // success callback
    function(coursesJarAndBody) {
      if (utils.isLoggedIn(coursesJarAndBody.body)) {
        deferred.resolve(coursesJarAndBody);
      } else {
        deferred.reject(new Error('couldnt resolve course selection'));
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseRegisteredCourses(options) {
  return function(promised_obj) {
    var deferred = q.defer();

    var url = CONSTANTS.URLS.registered_courses;
    var jar = promised_obj.jar;
    var form = {
      term_in: (options.year || '2025') + utils.fmtSeason(options.season)
    };

    Request.post(url, jar, form)
    .then(

    // success callback
    function(promised_obj) {
      if (utils.isLoggedIn(promised_obj.body)) {
        deferred.resolve(promised_obj);
      } else {
        deferred.reject(new Error('couldnt get list of registered_courses'));
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseAddOrDropCourse(drop, selection) {
  return function(promised_obj) {
    // First, we need to get the current registered courses to build the proper form
    var deferred = q.defer();
    
    // Get current registered courses first
    var url = CONSTANTS.URLS.registered_courses;
    var jar = promised_obj.jar;
    var sn = utils.fmtSeason(selection.season);
    var termCode = (selection.year || '2025') + sn;
    
    var form = {
      term_in: termCode
    };

    Request.post(url, jar, form)
    .then(function(registeredCoursesResponse) {
      // Parse the current registered courses
      var currentCourses = Parser.parseRegisteredCourses(registeredCoursesResponse.body);
      
      // Now build the add/drop form based on current state
      function buildAddDropForm(currentCourses, sel, isDrop) {
        var form = [
          "term_in=" + termCode,
          "&RSTS_IN=DUMMY",
          "&assoc_term_in=DUMMY", 
          "&CRN_IN=DUMMY",
          "&start_date_in=DUMMY",
          "&end_date_in=DUMMY",
          "&SUBJ=DUMMY",
          "&CRSE=DUMMY",
          "&SEC=DUMMY",
          "&LEVL=DUMMY",
          "&CRED=DUMMY",
          "&GMOD=DUMMY",
          "&TITLE=DUMMY",
          "&MESG=DUMMY",
          "&REG_BTN=DUMMY",
          "&MESG=DUMMY"
        ].join('');

        // Convert CRN to array if it's not already
        if (!(sel.crn instanceof Array)) {
          sel.crn = [sel.crn];
        }

        // Add entries for each currently registered course with full details
        _.forEach(currentCourses, function(course) {
          if (course.crn) {
            // Check if this course is being dropped
            var isBeingDropped = isDrop && _.includes(sel.crn, course.crn.toString());
            
            form += [
              "&RSTS_IN=" + (isBeingDropped ? "DW" : ""),
              "&assoc_term_in=" + termCode,
              "&CRN_IN=" + course.crn,
              "&start_date_in=" + (course.start_date || "08/27/2025"),
              "&end_date_in=" + (course.end_date || "12/03/2025"),
              "&SUBJ=" + (course.department || ""),
              "&CRSE=" + (course.course_number || ""),
              "&SEC=" + (course.section || ""),
              "&LEVL=" + (course.level || "Undergraduate"),
              "&CRED=" + (course.credit || ""),
              "&GMOD=" + (course.gmod || "Standard"),
              "&TITLE=" + (course.title || ""),
              "&MESG=DUMMY"
            ].join('');
          }
        });

        // For adding courses, add RW entries for new courses
        if (!isDrop) {
          _.forEach(sel.crn, function(crn) {
            form += [
              "&RSTS_IN=RW",
              "&CRN_IN=" + crn,
              "&assoc_term_in=",
              "&start_date_in=",
              "&end_date_in="
            ].join('');
          });
        }

        // Add empty RW slots (always 10 empty slots at the end)
        for (var i = 0; i < 10; i++) {
          form += [
            "&RSTS_IN=RW",
            "&CRN_IN=",
            "&assoc_term_in=",
            "&start_date_in=",
            "&end_date_in="
          ].join('');
        }

        // Add the footer - regs_row should be the total number of registered courses
        form += [
          "&regs_row=" + currentCourses.length,
          "&wait_row=0",
          "&add_row=10",
          "&REG_BTN=Submit+Changes"
        ].join('');

        return form;
      }

      // Build the form and make the add/drop request
      var addDropForm = buildAddDropForm(currentCourses, selection, drop);
      var addDropUrl = CONSTANTS.URLS.add_courses;

      Request.post(addDropUrl, jar, addDropForm)
      .then(function(promised_obj) {
        if (utils.isLoggedIn(promised_obj.body)) {
          deferred.resolve(promised_obj);
        } else {
          deferred.reject(new Error('Either couldnt login, or 404, or 400 bad request'));
        }
      })
      .catch(function(err) {
        deferred.reject(err);
      });
    })
    .catch(function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  };
}

function promiseAddCourses(selection) {
  return promiseAddOrDropCourse(false, selection);
}

function promiseDropCourses(selection) {
  return promiseAddOrDropCourse(true, selection);
}

var Minerva = function(u, p) {
  this.username = u || process.env.MG_USER;
  this.password = p || process.env.MG_PASS;
};

Minerva.prototype = {

  // for testing and backward compatibility
  login: function() {
    return login(this);
  },

  getTranscript: function() {
    var deferred = q.defer();

    login(this)
    .then(promiseTranscript())
    .then(

    // success callback
    function(promised_obj) {
      var html = promised_obj.body;
      if (!utils.isLoggedIn(html)) {
        deferred.reject(new Error('404'));
      } else {
        deferred.resolve(Parser.parseTranscript(html));
      }
    },

    // failure callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  getCourses: function(selection) {
    var deferred = q.defer();

    login(this)
    .then(promiseCourses(selection))
    .then(

    // success callback
    function(promised_obj) {
      deferred.resolve(Parser.parseCourses(promised_obj.body));
    },

    // failure callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  getRegisteredCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseRegisteredCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      deferred.resolve(Parser.parseRegisteredCourses(promised_obj.body));
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  addCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseAddCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      var courses = Parser.parseRegisteredCourses(promised_obj.body);
      var error = _.find(courses, 'ErrorMsg');
      if (error) {
        deferred.reject(new Error(error.ErrorMsg));
      } else {
        deferred.resolve(courses);
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },

  dropCourses: function(options) {
    var deferred = q.defer();

    login(this)
    .then(promiseDropCourses(options))
    .then(

    // success callback
    function(promised_obj) {
      var courses = Parser.parseRegisteredCourses(promised_obj.body);
      var error = _.find(courses, 'ErrorMsg');
      if (error) {
        deferred.reject(new Error(error.ErrorMsg));
      } else {
        deferred.resolve(courses);
      }
    },

    // error callback
    function(err) {
      deferred.reject(err);
    });

    return deferred.promise;
  },
};


module.exports = Minerva;
